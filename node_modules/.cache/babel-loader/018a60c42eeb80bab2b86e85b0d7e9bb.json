{"ast":null,"code":"import { mix } from './mix.es.js';\nimport { noopReturn } from './noop.es.js';\nimport { fillOffset, defaultOffset } from './offset.es.js';\nimport { progress } from './progress.es.js';\nimport { getEasingForSegment } from './easing.es.js';\nimport { clamp } from './clamp.es.js';\n\nfunction interpolate(output, input = defaultOffset(output.length), easing = noopReturn) {\n  const length = output.length;\n  /**\n   * If the input length is lower than the output we\n   * fill the input to match. This currently assumes the input\n   * is an animation progress value so is a good candidate for\n   * moving outside the function.\n   */\n\n  const remainder = length - input.length;\n  remainder > 0 && fillOffset(input, remainder);\n  return t => {\n    let i = 0;\n\n    for (; i < length - 2; i++) {\n      if (t < input[i + 1]) break;\n    }\n\n    let progressInRange = clamp(0, 1, progress(input[i], input[i + 1], t));\n    const segmentEasing = getEasingForSegment(easing, i);\n    progressInRange = segmentEasing(progressInRange);\n    return mix(output[i], output[i + 1], progressInRange);\n  };\n}\n\nexport { interpolate };","map":{"version":3,"sources":["C:/Users/daman/Desktop/Final Project/gadgetopia/frontend/node_modules/@motionone/utils/dist/interpolate.es.js"],"names":["mix","noopReturn","fillOffset","defaultOffset","progress","getEasingForSegment","clamp","interpolate","output","input","length","easing","remainder","t","i","progressInRange","segmentEasing"],"mappings":"AAAA,SAASA,GAAT,QAAoB,aAApB;AACA,SAASC,UAAT,QAA2B,cAA3B;AACA,SAASC,UAAT,EAAqBC,aAArB,QAA0C,gBAA1C;AACA,SAASC,QAAT,QAAyB,kBAAzB;AACA,SAASC,mBAAT,QAAoC,gBAApC;AACA,SAASC,KAAT,QAAsB,eAAtB;;AAEA,SAASC,WAAT,CAAqBC,MAArB,EAA6BC,KAAK,GAAGN,aAAa,CAACK,MAAM,CAACE,MAAR,CAAlD,EAAmEC,MAAM,GAAGV,UAA5E,EAAwF;AACpF,QAAMS,MAAM,GAAGF,MAAM,CAACE,MAAtB;AACA;AACJ;AACA;AACA;AACA;AACA;;AACI,QAAME,SAAS,GAAGF,MAAM,GAAGD,KAAK,CAACC,MAAjC;AACAE,EAAAA,SAAS,GAAG,CAAZ,IAAiBV,UAAU,CAACO,KAAD,EAAQG,SAAR,CAA3B;AACA,SAAQC,CAAD,IAAO;AACV,QAAIC,CAAC,GAAG,CAAR;;AACA,WAAOA,CAAC,GAAGJ,MAAM,GAAG,CAApB,EAAuBI,CAAC,EAAxB,EAA4B;AACxB,UAAID,CAAC,GAAGJ,KAAK,CAACK,CAAC,GAAG,CAAL,CAAb,EACI;AACP;;AACD,QAAIC,eAAe,GAAGT,KAAK,CAAC,CAAD,EAAI,CAAJ,EAAOF,QAAQ,CAACK,KAAK,CAACK,CAAD,CAAN,EAAWL,KAAK,CAACK,CAAC,GAAG,CAAL,CAAhB,EAAyBD,CAAzB,CAAf,CAA3B;AACA,UAAMG,aAAa,GAAGX,mBAAmB,CAACM,MAAD,EAASG,CAAT,CAAzC;AACAC,IAAAA,eAAe,GAAGC,aAAa,CAACD,eAAD,CAA/B;AACA,WAAOf,GAAG,CAACQ,MAAM,CAACM,CAAD,CAAP,EAAYN,MAAM,CAACM,CAAC,GAAG,CAAL,CAAlB,EAA2BC,eAA3B,CAAV;AACH,GAVD;AAWH;;AAED,SAASR,WAAT","sourcesContent":["import { mix } from './mix.es.js';\nimport { noopReturn } from './noop.es.js';\nimport { fillOffset, defaultOffset } from './offset.es.js';\nimport { progress } from './progress.es.js';\nimport { getEasingForSegment } from './easing.es.js';\nimport { clamp } from './clamp.es.js';\n\nfunction interpolate(output, input = defaultOffset(output.length), easing = noopReturn) {\n    const length = output.length;\n    /**\n     * If the input length is lower than the output we\n     * fill the input to match. This currently assumes the input\n     * is an animation progress value so is a good candidate for\n     * moving outside the function.\n     */\n    const remainder = length - input.length;\n    remainder > 0 && fillOffset(input, remainder);\n    return (t) => {\n        let i = 0;\n        for (; i < length - 2; i++) {\n            if (t < input[i + 1])\n                break;\n        }\n        let progressInRange = clamp(0, 1, progress(input[i], input[i + 1], t));\n        const segmentEasing = getEasingForSegment(easing, i);\n        progressInRange = segmentEasing(progressInRange);\n        return mix(output[i], output[i + 1], progressInRange);\n    };\n}\n\nexport { interpolate };\n"]},"metadata":{},"sourceType":"module"}