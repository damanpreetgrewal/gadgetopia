{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nconst defaultTimestep = 1 / 60 * 1000;\nconst getCurrentTime = typeof performance !== \"undefined\" ? () => performance.now() : () => Date.now();\nconst onNextFrame = typeof window !== \"undefined\" ? callback => window.requestAnimationFrame(callback) : callback => setTimeout(() => callback(getCurrentTime()), defaultTimestep);\n\nfunction createRenderStep(runNextFrame) {\n  let toRun = [];\n  let toRunNextFrame = [];\n  let numToRun = 0;\n  let isProcessing = false;\n  let flushNextFrame = false;\n  const toKeepAlive = new WeakSet();\n  const step = {\n    schedule: (callback, keepAlive = false, immediate = false) => {\n      const addToCurrentFrame = immediate && isProcessing;\n      const buffer = addToCurrentFrame ? toRun : toRunNextFrame;\n      if (keepAlive) toKeepAlive.add(callback);\n\n      if (buffer.indexOf(callback) === -1) {\n        buffer.push(callback);\n        if (addToCurrentFrame && isProcessing) numToRun = toRun.length;\n      }\n\n      return callback;\n    },\n    cancel: callback => {\n      const index = toRunNextFrame.indexOf(callback);\n      if (index !== -1) toRunNextFrame.splice(index, 1);\n      toKeepAlive.delete(callback);\n    },\n    process: frameData => {\n      if (isProcessing) {\n        flushNextFrame = true;\n        return;\n      }\n\n      isProcessing = true;\n      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];\n      toRunNextFrame.length = 0;\n      numToRun = toRun.length;\n\n      if (numToRun) {\n        for (let i = 0; i < numToRun; i++) {\n          const callback = toRun[i];\n          callback(frameData);\n\n          if (toKeepAlive.has(callback)) {\n            step.schedule(callback);\n            runNextFrame();\n          }\n        }\n      }\n\n      isProcessing = false;\n\n      if (flushNextFrame) {\n        flushNextFrame = false;\n        step.process(frameData);\n      }\n    }\n  };\n  return step;\n}\n\nconst maxElapsed = 40;\nlet useDefaultElapsed = true;\nlet runNextFrame = false;\nlet isProcessing = false;\nconst frame = {\n  delta: 0,\n  timestamp: 0\n};\nconst stepsOrder = [\"read\", \"update\", \"preRender\", \"render\", \"postRender\"];\nconst steps = stepsOrder.reduce((acc, key) => {\n  acc[key] = createRenderStep(() => runNextFrame = true);\n  return acc;\n}, {});\nconst sync = stepsOrder.reduce((acc, key) => {\n  const step = steps[key];\n\n  acc[key] = (process, keepAlive = false, immediate = false) => {\n    if (!runNextFrame) startLoop();\n    return step.schedule(process, keepAlive, immediate);\n  };\n\n  return acc;\n}, {});\nconst cancelSync = stepsOrder.reduce((acc, key) => {\n  acc[key] = steps[key].cancel;\n  return acc;\n}, {});\nconst flushSync = stepsOrder.reduce((acc, key) => {\n  acc[key] = () => steps[key].process(frame);\n\n  return acc;\n}, {});\n\nconst processStep = stepId => steps[stepId].process(frame);\n\nconst processFrame = timestamp => {\n  runNextFrame = false;\n  frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);\n  frame.timestamp = timestamp;\n  isProcessing = true;\n  stepsOrder.forEach(processStep);\n  isProcessing = false;\n\n  if (runNextFrame) {\n    useDefaultElapsed = false;\n    onNextFrame(processFrame);\n  }\n};\n\nconst startLoop = () => {\n  runNextFrame = true;\n  useDefaultElapsed = true;\n  if (!isProcessing) onNextFrame(processFrame);\n};\n\nconst getFrameData = () => frame;\n\nexports.cancelSync = cancelSync;\nexports.default = sync;\nexports.flushSync = flushSync;\nexports.getFrameData = getFrameData;","map":{"version":3,"sources":["C:/Users/daman/Desktop/Final Project/gadgetopia/frontend/node_modules/framesync/dist/framesync.cjs.js"],"names":["Object","defineProperty","exports","value","defaultTimestep","getCurrentTime","performance","now","Date","onNextFrame","window","callback","requestAnimationFrame","setTimeout","createRenderStep","runNextFrame","toRun","toRunNextFrame","numToRun","isProcessing","flushNextFrame","toKeepAlive","WeakSet","step","schedule","keepAlive","immediate","addToCurrentFrame","buffer","add","indexOf","push","length","cancel","index","splice","delete","process","frameData","i","has","maxElapsed","useDefaultElapsed","frame","delta","timestamp","stepsOrder","steps","reduce","acc","key","sync","startLoop","cancelSync","flushSync","processStep","stepId","processFrame","Math","max","min","forEach","getFrameData","default"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nconst defaultTimestep = (1 / 60) * 1000;\nconst getCurrentTime = typeof performance !== \"undefined\"\n    ? () => performance.now()\n    : () => Date.now();\nconst onNextFrame = typeof window !== \"undefined\"\n    ? (callback) => window.requestAnimationFrame(callback)\n    : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);\n\nfunction createRenderStep(runNextFrame) {\n    let toRun = [];\n    let toRunNextFrame = [];\n    let numToRun = 0;\n    let isProcessing = false;\n    let flushNextFrame = false;\n    const toKeepAlive = new WeakSet();\n    const step = {\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const buffer = addToCurrentFrame ? toRun : toRunNextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (buffer.indexOf(callback) === -1) {\n                buffer.push(callback);\n                if (addToCurrentFrame && isProcessing)\n                    numToRun = toRun.length;\n            }\n            return callback;\n        },\n        cancel: (callback) => {\n            const index = toRunNextFrame.indexOf(callback);\n            if (index !== -1)\n                toRunNextFrame.splice(index, 1);\n            toKeepAlive.delete(callback);\n        },\n        process: (frameData) => {\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [toRun, toRunNextFrame] = [toRunNextFrame, toRun];\n            toRunNextFrame.length = 0;\n            numToRun = toRun.length;\n            if (numToRun) {\n                for (let i = 0; i < numToRun; i++) {\n                    const callback = toRun[i];\n                    callback(frameData);\n                    if (toKeepAlive.has(callback)) {\n                        step.schedule(callback);\n                        runNextFrame();\n                    }\n                }\n            }\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\nconst maxElapsed = 40;\nlet useDefaultElapsed = true;\nlet runNextFrame = false;\nlet isProcessing = false;\nconst frame = {\n    delta: 0,\n    timestamp: 0,\n};\nconst stepsOrder = [\n    \"read\",\n    \"update\",\n    \"preRender\",\n    \"render\",\n    \"postRender\",\n];\nconst steps = stepsOrder.reduce((acc, key) => {\n    acc[key] = createRenderStep(() => (runNextFrame = true));\n    return acc;\n}, {});\nconst sync = stepsOrder.reduce((acc, key) => {\n    const step = steps[key];\n    acc[key] = (process, keepAlive = false, immediate = false) => {\n        if (!runNextFrame)\n            startLoop();\n        return step.schedule(process, keepAlive, immediate);\n    };\n    return acc;\n}, {});\nconst cancelSync = stepsOrder.reduce((acc, key) => {\n    acc[key] = steps[key].cancel;\n    return acc;\n}, {});\nconst flushSync = stepsOrder.reduce((acc, key) => {\n    acc[key] = () => steps[key].process(frame);\n    return acc;\n}, {});\nconst processStep = (stepId) => steps[stepId].process(frame);\nconst processFrame = (timestamp) => {\n    runNextFrame = false;\n    frame.delta = useDefaultElapsed\n        ? defaultTimestep\n        : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);\n    frame.timestamp = timestamp;\n    isProcessing = true;\n    stepsOrder.forEach(processStep);\n    isProcessing = false;\n    if (runNextFrame) {\n        useDefaultElapsed = false;\n        onNextFrame(processFrame);\n    }\n};\nconst startLoop = () => {\n    runNextFrame = true;\n    useDefaultElapsed = true;\n    if (!isProcessing)\n        onNextFrame(processFrame);\n};\nconst getFrameData = () => frame;\n\nexports.cancelSync = cancelSync;\nexports.default = sync;\nexports.flushSync = flushSync;\nexports.getFrameData = getFrameData;\n"]},"metadata":{},"sourceType":"script"}