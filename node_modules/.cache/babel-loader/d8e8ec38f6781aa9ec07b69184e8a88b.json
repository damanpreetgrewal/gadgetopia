{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar utils = require('@motionone/utils');\n\nvar edge = require('./edge.cjs.js');\n\nconst defaultOffset = [0, 0];\n\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n  let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n  let targetPoint = 0;\n  let containerPoint = 0;\n\n  if (utils.isNumber(offset)) {\n    /**\n     * If we're provided offset: [0, 0.5, 1] then each number x should become\n     * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n     * and container etc.\n     */\n    offsetDefinition = [offset, offset];\n  } else if (utils.isString(offset)) {\n    offset = offset.trim();\n\n    if (offset.includes(\" \")) {\n      offsetDefinition = offset.split(\" \");\n    } else {\n      /**\n       * If we're provided a definition like \"100px\" then we want to apply\n       * that only to the top of the target point, leaving the container at 0.\n       * Whereas a named offset like \"end\" should be applied to both.\n       */\n      offsetDefinition = [offset, edge.namedEdges[offset] ? offset : `0`];\n    }\n  }\n\n  targetPoint = edge.resolveEdge(offsetDefinition[0], targetLength, targetInset);\n  containerPoint = edge.resolveEdge(offsetDefinition[1], containerLength);\n  return targetPoint - containerPoint;\n}\n\nexports.resolveOffset = resolveOffset;","map":{"version":3,"sources":["C:/Users/daman/Desktop/Final Project/gadgetopia/frontend/node_modules/@motionone/dom/dist/gestures/scroll/offsets/offset.cjs.js"],"names":["Object","defineProperty","exports","value","utils","require","edge","defaultOffset","resolveOffset","offset","containerLength","targetLength","targetInset","offsetDefinition","Array","isArray","targetPoint","containerPoint","isNumber","isString","trim","includes","split","namedEdges","resolveEdge"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AAEA,IAAIC,KAAK,GAAGC,OAAO,CAAC,kBAAD,CAAnB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,eAAD,CAAlB;;AAEA,MAAME,aAAa,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAtB;;AACA,SAASC,aAAT,CAAuBC,MAAvB,EAA+BC,eAA/B,EAAgDC,YAAhD,EAA8DC,WAA9D,EAA2E;AACvE,MAAIC,gBAAgB,GAAGC,KAAK,CAACC,OAAN,CAAcN,MAAd,IAAwBA,MAAxB,GAAiCF,aAAxD;AACA,MAAIS,WAAW,GAAG,CAAlB;AACA,MAAIC,cAAc,GAAG,CAArB;;AACA,MAAIb,KAAK,CAACc,QAAN,CAAeT,MAAf,CAAJ,EAA4B;AACxB;AACR;AACA;AACA;AACA;AACQI,IAAAA,gBAAgB,GAAG,CAACJ,MAAD,EAASA,MAAT,CAAnB;AACH,GAPD,MAQK,IAAIL,KAAK,CAACe,QAAN,CAAeV,MAAf,CAAJ,EAA4B;AAC7BA,IAAAA,MAAM,GAAGA,MAAM,CAACW,IAAP,EAAT;;AACA,QAAIX,MAAM,CAACY,QAAP,CAAgB,GAAhB,CAAJ,EAA0B;AACtBR,MAAAA,gBAAgB,GAAGJ,MAAM,CAACa,KAAP,CAAa,GAAb,CAAnB;AACH,KAFD,MAGK;AACD;AACZ;AACA;AACA;AACA;AACYT,MAAAA,gBAAgB,GAAG,CAACJ,MAAD,EAASH,IAAI,CAACiB,UAAL,CAAgBd,MAAhB,IAA0BA,MAA1B,GAAoC,GAA7C,CAAnB;AACH;AACJ;;AACDO,EAAAA,WAAW,GAAGV,IAAI,CAACkB,WAAL,CAAiBX,gBAAgB,CAAC,CAAD,CAAjC,EAAsCF,YAAtC,EAAoDC,WAApD,CAAd;AACAK,EAAAA,cAAc,GAAGX,IAAI,CAACkB,WAAL,CAAiBX,gBAAgB,CAAC,CAAD,CAAjC,EAAsCH,eAAtC,CAAjB;AACA,SAAOM,WAAW,GAAGC,cAArB;AACH;;AAEDf,OAAO,CAACM,aAAR,GAAwBA,aAAxB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar utils = require('@motionone/utils');\nvar edge = require('./edge.cjs.js');\n\nconst defaultOffset = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n    let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;\n    let targetPoint = 0;\n    let containerPoint = 0;\n    if (utils.isNumber(offset)) {\n        /**\n         * If we're provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset];\n    }\n    else if (utils.isString(offset)) {\n        offset = offset.trim();\n        if (offset.includes(\" \")) {\n            offsetDefinition = offset.split(\" \");\n        }\n        else {\n            /**\n             * If we're provided a definition like \"100px\" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like \"end\" should be applied to both.\n             */\n            offsetDefinition = [offset, edge.namedEdges[offset] ? offset : `0`];\n        }\n    }\n    targetPoint = edge.resolveEdge(offsetDefinition[0], targetLength, targetInset);\n    containerPoint = edge.resolveEdge(offsetDefinition[1], containerLength);\n    return targetPoint - containerPoint;\n}\n\nexports.resolveOffset = resolveOffset;\n"]},"metadata":{},"sourceType":"script"}