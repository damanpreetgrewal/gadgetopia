{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar utils = require('@motionone/utils');\n\nvar stopAnimation = require('./stop-animation.cjs.js');\n\nconst createAnimation = factory => factory();\n\nconst withControls = (animationFactory, options, duration = utils.defaults.duration) => {\n  return new Proxy({\n    animations: animationFactory.map(createAnimation).filter(Boolean),\n    duration,\n    options\n  }, controls);\n};\n/**\n * TODO:\n * Currently this returns the first animation, ideally it would return\n * the first active animation.\n */\n\n\nconst getActiveAnimation = state => state.animations[0];\n\nconst controls = {\n  get: (target, key) => {\n    const activeAnimation = getActiveAnimation(target);\n\n    switch (key) {\n      case \"duration\":\n        return target.duration;\n\n      case \"currentTime\":\n        return utils.time.s((activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) || 0);\n\n      case \"playbackRate\":\n      case \"playState\":\n        return activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key];\n\n      case \"finished\":\n        if (!target.finished) {\n          target.finished = Promise.all(target.animations.map(selectFinished)).catch(utils.noop);\n        }\n\n        return target.finished;\n\n      case \"stop\":\n        return () => {\n          target.animations.forEach(animation => stopAnimation.stopAnimation(animation));\n        };\n\n      case \"forEachNative\":\n        /**\n         * This is for internal use only, fire a callback for each\n         * underlying animation.\n         */\n        return callback => {\n          target.animations.forEach(animation => callback(animation, target));\n        };\n\n      default:\n        return typeof (activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) === \"undefined\" ? undefined : () => target.animations.forEach(animation => animation[key]());\n    }\n  },\n  set: (target, key, value) => {\n    switch (key) {\n      case \"currentTime\":\n        value = utils.time.ms(value);\n\n      case \"currentTime\":\n      case \"playbackRate\":\n        for (let i = 0; i < target.animations.length; i++) {\n          target.animations[i][key] = value;\n        }\n\n        return true;\n    }\n\n    return false;\n  }\n};\n\nconst selectFinished = animation => animation.finished;\n\nexports.controls = controls;\nexports.withControls = withControls;","map":{"version":3,"sources":["C:/Users/daman/Desktop/Final Project/gadgetopia/frontend/node_modules/@motionone/dom/dist/animate/utils/controls.cjs.js"],"names":["Object","defineProperty","exports","value","utils","require","stopAnimation","createAnimation","factory","withControls","animationFactory","options","duration","defaults","Proxy","animations","map","filter","Boolean","controls","getActiveAnimation","state","get","target","key","activeAnimation","time","s","finished","Promise","all","selectFinished","catch","noop","forEach","animation","callback","undefined","set","ms","i","length"],"mappings":"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","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar utils = require('@motionone/utils');\nvar stopAnimation = require('./stop-animation.cjs.js');\n\nconst createAnimation = (factory) => factory();\nconst withControls = (animationFactory, options, duration = utils.defaults.duration) => {\n    return new Proxy({\n        animations: animationFactory.map(createAnimation).filter(Boolean),\n        duration,\n        options,\n    }, controls);\n};\n/**\n * TODO:\n * Currently this returns the first animation, ideally it would return\n * the first active animation.\n */\nconst getActiveAnimation = (state) => state.animations[0];\nconst controls = {\n    get: (target, key) => {\n        const activeAnimation = getActiveAnimation(target);\n        switch (key) {\n            case \"duration\":\n                return target.duration;\n            case \"currentTime\":\n                return utils.time.s((activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) || 0);\n            case \"playbackRate\":\n            case \"playState\":\n                return activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key];\n            case \"finished\":\n                if (!target.finished) {\n                    target.finished = Promise.all(target.animations.map(selectFinished)).catch(utils.noop);\n                }\n                return target.finished;\n            case \"stop\":\n                return () => {\n                    target.animations.forEach((animation) => stopAnimation.stopAnimation(animation));\n                };\n            case \"forEachNative\":\n                /**\n                 * This is for internal use only, fire a callback for each\n                 * underlying animation.\n                 */\n                return (callback) => {\n                    target.animations.forEach((animation) => callback(animation, target));\n                };\n            default:\n                return typeof (activeAnimation === null || activeAnimation === void 0 ? void 0 : activeAnimation[key]) === \"undefined\"\n                    ? undefined\n                    : () => target.animations.forEach((animation) => animation[key]());\n        }\n    },\n    set: (target, key, value) => {\n        switch (key) {\n            case \"currentTime\":\n                value = utils.time.ms(value);\n            case \"currentTime\":\n            case \"playbackRate\":\n                for (let i = 0; i < target.animations.length; i++) {\n                    target.animations[i][key] = value;\n                }\n                return true;\n        }\n        return false;\n    },\n};\nconst selectFinished = (animation) => animation.finished;\n\nexports.controls = controls;\nexports.withControls = withControls;\n"]},"metadata":{},"sourceType":"script"}