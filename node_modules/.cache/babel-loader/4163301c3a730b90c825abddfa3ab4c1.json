{"ast":null,"code":"var identityProjection = \"translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)\";\n\nfunction buildProjectionTransform(delta, treeScale, latestTransform) {\n  /**\n   * The translations we use to calculate are always relative to the viewport coordinate space.\n   * But when we apply scales, we also scale the coordinate space of an element and its children.\n   * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n   * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n   */\n  var xTranslate = delta.x.translate / treeScale.x;\n  var yTranslate = delta.y.translate / treeScale.y;\n  var transform = \"translate3d(\".concat(xTranslate, \"px, \").concat(yTranslate, \"px, 0) \");\n  /**\n   * Apply scale correction for the tree transform.\n   * This will apply scale to the screen-orientated axes.\n   */\n\n  transform += \"scale(\".concat(1 / treeScale.x, \", \").concat(1 / treeScale.y, \") \");\n\n  if (latestTransform) {\n    var rotate = latestTransform.rotate,\n        rotateX = latestTransform.rotateX,\n        rotateY = latestTransform.rotateY;\n    if (rotate) transform += \"rotate(\".concat(rotate, \"deg) \");\n    if (rotateX) transform += \"rotateX(\".concat(rotateX, \"deg) \");\n    if (rotateY) transform += \"rotateY(\".concat(rotateY, \"deg) \");\n  }\n  /**\n   * Apply scale to match the size of the element to the size we want it.\n   * This will apply scale to the element-orientated axes.\n   */\n\n\n  var elementScaleX = delta.x.scale * treeScale.x;\n  var elementScaleY = delta.y.scale * treeScale.y;\n  transform += \"scale(\".concat(elementScaleX, \", \").concat(elementScaleY, \")\");\n  return transform === identityProjection ? \"none\" : transform;\n}\n\nexport { buildProjectionTransform, identityProjection };","map":{"version":3,"sources":["C:/Users/daman/Desktop/Final Project/gadgetopia/frontend/node_modules/framer-motion/dist/es/projection/styles/transform.mjs"],"names":["identityProjection","buildProjectionTransform","delta","treeScale","latestTransform","xTranslate","x","translate","yTranslate","y","transform","concat","rotate","rotateX","rotateY","elementScaleX","scale","elementScaleY"],"mappings":"AAAA,IAAIA,kBAAkB,GAAG,kDAAzB;;AACA,SAASC,wBAAT,CAAkCC,KAAlC,EAAyCC,SAAzC,EAAoDC,eAApD,EAAqE;AACjE;AACJ;AACA;AACA;AACA;AACA;AACI,MAAIC,UAAU,GAAGH,KAAK,CAACI,CAAN,CAAQC,SAAR,GAAoBJ,SAAS,CAACG,CAA/C;AACA,MAAIE,UAAU,GAAGN,KAAK,CAACO,CAAN,CAAQF,SAAR,GAAoBJ,SAAS,CAACM,CAA/C;AACA,MAAIC,SAAS,GAAG,eAAeC,MAAf,CAAsBN,UAAtB,EAAkC,MAAlC,EAA0CM,MAA1C,CAAiDH,UAAjD,EAA6D,SAA7D,CAAhB;AACA;AACJ;AACA;AACA;;AACIE,EAAAA,SAAS,IAAI,SAASC,MAAT,CAAgB,IAAIR,SAAS,CAACG,CAA9B,EAAiC,IAAjC,EAAuCK,MAAvC,CAA8C,IAAIR,SAAS,CAACM,CAA5D,EAA+D,IAA/D,CAAb;;AACA,MAAIL,eAAJ,EAAqB;AACjB,QAAIQ,MAAM,GAAGR,eAAe,CAACQ,MAA7B;AAAA,QAAqCC,OAAO,GAAGT,eAAe,CAACS,OAA/D;AAAA,QAAwEC,OAAO,GAAGV,eAAe,CAACU,OAAlG;AACA,QAAIF,MAAJ,EACIF,SAAS,IAAI,UAAUC,MAAV,CAAiBC,MAAjB,EAAyB,OAAzB,CAAb;AACJ,QAAIC,OAAJ,EACIH,SAAS,IAAI,WAAWC,MAAX,CAAkBE,OAAlB,EAA2B,OAA3B,CAAb;AACJ,QAAIC,OAAJ,EACIJ,SAAS,IAAI,WAAWC,MAAX,CAAkBG,OAAlB,EAA2B,OAA3B,CAAb;AACP;AACD;AACJ;AACA;AACA;;;AACI,MAAIC,aAAa,GAAGb,KAAK,CAACI,CAAN,CAAQU,KAAR,GAAgBb,SAAS,CAACG,CAA9C;AACA,MAAIW,aAAa,GAAGf,KAAK,CAACO,CAAN,CAAQO,KAAR,GAAgBb,SAAS,CAACM,CAA9C;AACAC,EAAAA,SAAS,IAAI,SAASC,MAAT,CAAgBI,aAAhB,EAA+B,IAA/B,EAAqCJ,MAArC,CAA4CM,aAA5C,EAA2D,GAA3D,CAAb;AACA,SAAOP,SAAS,KAAKV,kBAAd,GAAmC,MAAnC,GAA4CU,SAAnD;AACH;;AAED,SAAST,wBAAT,EAAmCD,kBAAnC","sourcesContent":["var identityProjection = \"translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)\";\nfunction buildProjectionTransform(delta, treeScale, latestTransform) {\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    var xTranslate = delta.x.translate / treeScale.x;\n    var yTranslate = delta.y.translate / treeScale.y;\n    var transform = \"translate3d(\".concat(xTranslate, \"px, \").concat(yTranslate, \"px, 0) \");\n    /**\n     * Apply scale correction for the tree transform.\n     * This will apply scale to the screen-orientated axes.\n     */\n    transform += \"scale(\".concat(1 / treeScale.x, \", \").concat(1 / treeScale.y, \") \");\n    if (latestTransform) {\n        var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;\n        if (rotate)\n            transform += \"rotate(\".concat(rotate, \"deg) \");\n        if (rotateX)\n            transform += \"rotateX(\".concat(rotateX, \"deg) \");\n        if (rotateY)\n            transform += \"rotateY(\".concat(rotateY, \"deg) \");\n    }\n    /**\n     * Apply scale to match the size of the element to the size we want it.\n     * This will apply scale to the element-orientated axes.\n     */\n    var elementScaleX = delta.x.scale * treeScale.x;\n    var elementScaleY = delta.y.scale * treeScale.y;\n    transform += \"scale(\".concat(elementScaleX, \", \").concat(elementScaleY, \")\");\n    return transform === identityProjection ? \"none\" : transform;\n}\n\nexport { buildProjectionTransform, identityProjection };\n"]},"metadata":{},"sourceType":"module"}