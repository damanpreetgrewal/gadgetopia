{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar animateStyle = require('./animate-style.cjs.js');\n\nvar options = require('./utils/options.cjs.js');\n\nvar resolveElements = require('../utils/resolve-elements.cjs.js');\n\nvar controls = require('./utils/controls.cjs.js');\n\nvar stagger = require('../utils/stagger.cjs.js');\n\nfunction animate(elements, keyframes, options$1 = {}) {\n  elements = resolveElements.resolveElements(elements);\n  const numElements = elements.length;\n  /**\n   * Create and start new animations\n   */\n\n  const animationFactories = [];\n\n  for (let i = 0; i < numElements; i++) {\n    const element = elements[i];\n\n    for (const key in keyframes) {\n      const valueOptions = options.getOptions(options$1, key);\n      valueOptions.delay = stagger.resolveOption(valueOptions.delay, i, numElements);\n      const animation = animateStyle.animateStyle(element, key, keyframes[key], valueOptions);\n      animationFactories.push(animation);\n    }\n  }\n\n  return controls.withControls(animationFactories, options$1,\n  /**\n   * TODO:\n   * If easing is set to spring or glide, duration will be dynamically\n   * generated. Ideally we would dynamically generate this from\n   * animation.effect.getComputedTiming().duration but this isn't\n   * supported in iOS13 or our number polyfill. Perhaps it's possible\n   * to Proxy animations returned from animateStyle that has duration\n   * as a getter.\n   */\n  options$1.duration);\n}\n\nexports.animate = animate;","map":{"version":3,"sources":["C:/Users/daman/Desktop/Final Project/gadgetopia/frontend/node_modules/@motionone/dom/dist/animate/index.cjs.js"],"names":["Object","defineProperty","exports","value","animateStyle","require","options","resolveElements","controls","stagger","animate","elements","keyframes","options$1","numElements","length","animationFactories","i","element","key","valueOptions","getOptions","delay","resolveOption","animation","push","withControls","duration"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AAEA,IAAIC,YAAY,GAAGC,OAAO,CAAC,wBAAD,CAA1B;;AACA,IAAIC,OAAO,GAAGD,OAAO,CAAC,wBAAD,CAArB;;AACA,IAAIE,eAAe,GAAGF,OAAO,CAAC,kCAAD,CAA7B;;AACA,IAAIG,QAAQ,GAAGH,OAAO,CAAC,yBAAD,CAAtB;;AACA,IAAII,OAAO,GAAGJ,OAAO,CAAC,yBAAD,CAArB;;AAEA,SAASK,OAAT,CAAiBC,QAAjB,EAA2BC,SAA3B,EAAsCC,SAAS,GAAG,EAAlD,EAAsD;AAClDF,EAAAA,QAAQ,GAAGJ,eAAe,CAACA,eAAhB,CAAgCI,QAAhC,CAAX;AACA,QAAMG,WAAW,GAAGH,QAAQ,CAACI,MAA7B;AACA;AACJ;AACA;;AACI,QAAMC,kBAAkB,GAAG,EAA3B;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,WAApB,EAAiCG,CAAC,EAAlC,EAAsC;AAClC,UAAMC,OAAO,GAAGP,QAAQ,CAACM,CAAD,CAAxB;;AACA,SAAK,MAAME,GAAX,IAAkBP,SAAlB,EAA6B;AACzB,YAAMQ,YAAY,GAAGd,OAAO,CAACe,UAAR,CAAmBR,SAAnB,EAA8BM,GAA9B,CAArB;AACAC,MAAAA,YAAY,CAACE,KAAb,GAAqBb,OAAO,CAACc,aAAR,CAAsBH,YAAY,CAACE,KAAnC,EAA0CL,CAA1C,EAA6CH,WAA7C,CAArB;AACA,YAAMU,SAAS,GAAGpB,YAAY,CAACA,YAAb,CAA0Bc,OAA1B,EAAmCC,GAAnC,EAAwCP,SAAS,CAACO,GAAD,CAAjD,EAAwDC,YAAxD,CAAlB;AACAJ,MAAAA,kBAAkB,CAACS,IAAnB,CAAwBD,SAAxB;AACH;AACJ;;AACD,SAAOhB,QAAQ,CAACkB,YAAT,CAAsBV,kBAAtB,EAA0CH,SAA1C;AACP;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACIA,EAAAA,SAAS,CAACc,QAVH,CAAP;AAWH;;AAEDzB,OAAO,CAACQ,OAAR,GAAkBA,OAAlB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar animateStyle = require('./animate-style.cjs.js');\nvar options = require('./utils/options.cjs.js');\nvar resolveElements = require('../utils/resolve-elements.cjs.js');\nvar controls = require('./utils/controls.cjs.js');\nvar stagger = require('../utils/stagger.cjs.js');\n\nfunction animate(elements, keyframes, options$1 = {}) {\n    elements = resolveElements.resolveElements(elements);\n    const numElements = elements.length;\n    /**\n     * Create and start new animations\n     */\n    const animationFactories = [];\n    for (let i = 0; i < numElements; i++) {\n        const element = elements[i];\n        for (const key in keyframes) {\n            const valueOptions = options.getOptions(options$1, key);\n            valueOptions.delay = stagger.resolveOption(valueOptions.delay, i, numElements);\n            const animation = animateStyle.animateStyle(element, key, keyframes[key], valueOptions);\n            animationFactories.push(animation);\n        }\n    }\n    return controls.withControls(animationFactories, options$1, \n    /**\n     * TODO:\n     * If easing is set to spring or glide, duration will be dynamically\n     * generated. Ideally we would dynamically generate this from\n     * animation.effect.getComputedTiming().duration but this isn't\n     * supported in iOS13 or our number polyfill. Perhaps it's possible\n     * to Proxy animations returned from animateStyle that has duration\n     * as a getter.\n     */\n    options$1.duration);\n}\n\nexports.animate = animate;\n"]},"metadata":{},"sourceType":"script"}